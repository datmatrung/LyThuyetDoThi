https://www.geeksforgeeks.org/check-if-a-graph-is-strongly-unilaterally-or-weakly-connected/
1. Tạo ma trận đường đi từ ma trận kề
        
        
    class Graph
    {
        public int V;
        public List<int>[] a;

        public Graph(int v)
        {
            V = v;
            a = new List<int>[v];
            for (int i = 0; i < v; ++i)
                a[i] = new List<int>();
        }
        public void ThemCanh(int v, int w)
        {
            a[v].Add(w); 
        }
        public void XuatDFS(int v, bool[] tham)
        {
            tham[v] = true;
            List<int> vList = a[v];
            foreach (var n in vList)
            {
                if (!tham[n])
                    XuatDFS(n, tham);
            }
        }
       
    private bool LienThongManh()
        {
            int[,] A = TaoMaTranDuongDi();
            bool LienThongManh = true;
            for (int i = 0; i < g.n; i++)
            {
                for (int j = 0; j < g.n; j++)
                {
                    if (A[i, j] == 0)
                    {
                        LienThongManh = false;
                        break;
                    }
                }
            }
            return LienThongManh;
        }
        private bool LienThongTungPhan()
        {
            int[,] A = TaoMaTranDuongDi();
            bool LienThongTungPhan = true;
            for (int i = 0; i < g.n; i++)
            {
                for (int j = 0; j < g.n; j++)
                {
                    if (A[i, j] == 0 & A[j, i] == 0)
                    {
                        LienThongTungPhan = false;
                        break;
                    }
                }
            }
            return LienThongTungPhan;
        }
        private int[,] TaoMaTranVoHuong()
        {
            int n = g.n;
            Graph f = new Graph(n);
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    if (g.a[i, j] == 1)
                        f.ThemCanh(i, j);
                }
            }
            Graph k = new Graph(n);
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < f.a[i].Count; j++)
                {
                    k.ThemCanh(i, f.a[i][j]);
                    k.ThemCanh(f.a[i][j], i);
                }
            }
            int[,] A = new int[n, n];
            for (int i = 0; i < n; i++)
            {
                bool[] tham = new bool[n];
                k.XuatDFS(i, tham);
                for (int j = 0; j < n; j++)
                {
                    if (tham[j] == true)
                        A[i, j] = 1;
                }
            }
            return A;
        }
        private bool LienThongYeu()
        { 
            bool LienThongYeu = true;
            int[,] A = TaoMaTranVoHuong();
            for (int i = 0; i < g.n; i++)
            {
                for (int j = 0; j < g.n; j++)
                {
                    if (A[i, j] == 0)
                    {
                        LienThongYeu = false;
                        break;
                    }
                }
            }
            return LienThongYeu;
        }
        private int[,] TaoMaTranDuongDi()
        {
            int n = g.n;
            Graph f = new Graph(n);
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    if (g.a[i, j] == 1)
                        f.ThemCanh(i, j);
                }
            }
            int[,] A = new int[n, n];
            for (int i = 0; i < n; i++)
            {
                bool[] tham = new bool[n];
                f.XuatDFS(i, tham);
                for (int j = 0; j < n; j++)
                {
                    if (tham[j] == true)
                        A[i, j] = 1;
                }
            }
            return A;
        }
        }
